#
# Makefile for AVL3.45 using Intel fortran for Windows
# H.Youngren 5/12/2023, S.Allmaras 2/24/22
#

BINDIR = .
SRC = ..\src

PROGS = avl.exe


AOBJS = avl_heap_inc.o avl_heap.o \
avl.o aoper.o amode.o amass.o asetup.o \
amake.o ainput.o aoutput.o aoutmrf.o aero.o atrim.o atpforc.o \
aic.o cdcl.o airutil.o autil.o aoml.o \
aplotvl.o aplottp.o aplotmd.o limits.o \
pltops.o hidden.o \
plsubs.o \
obsetup.o \
userio.o plutil.o arrow3d.o getvm.o \
spline.o sgutil.o \
second.o

MLIB =
MLIBSYS =
# Original generic matrix solver (slow but self-contained)
#MATRIX = matrix.obj



# Use the lapack solvers for faster matrix solves
# Single precision
#MATRIX = matrix-lapacksp.obj  
# Double precision
MATRIX = matrix-lapackdp.obj
# This requires AVL to be linked with LAPACK and BLAS routines

# Compile selected lapack and blas sources
MLIB = matrix-lapacksubs.obj

# or Link with system lapack and blas libraries
#MLIBSYS = -llapack -lblas
# or Link with system openblas libraries
#MLIBSYS =  -lopenblas
# Alternatively link with the very fast Intel Math Kernel Library
#MLIBSSYS = -lmkl
# Intel MKL (fast!)
#MLIBSYS = /Qmkl:sequential
MLIBSSY = /Qmkl


# libraries needed
PLTOBJ = ..\plotlib\libPlt_ifort.lib
EIGOBJ = ..\eispack\libeispack.lib

###================================================
###  Default compilers and flags
FC = f77
OPT =
DP =
GFIX =
DBG =
LFLG =

PLTLIB = gdi32.lib user32.lib
FTNLIB =
#Subroutine SECOND source file
SECOND = second_ifc.f


##---------------------------------------
##  Setup for Intel fortran, links executable to Win32
FC = ifort
OPT = /O2

ACHK = 
# Debug flags (symbols, array bounds)
#DBG = /g /O0 
#ACHK = /CB /fpe-all

FTNLIB =
SECOND = second_ifc.f

# single precision
PLTOBJ = ..\plotlib\libPlt_ifortSP.lib

# double precision
DP = /4R8
PLTOBJ = ..\plotlib\libPlt_ifortDP.lib

FFLAGS = $(OPT) $(DBG) $(ACHK) $(DP) /Qmkl
FFLGNODP = $(OPT) $(DBG) $(ACHK) /Qmkl

# Windows libraries
PLTLIB = gdi32.lib user32.lib
#LIBS = gdi32.lib user32.lib /LINK /NODEFAULTLIB:LIBC.LIB
#
# to make static executable
LFLG = -static
##---------------------------------------



all:	 $(PROGS)

clean:
	del $(PROGS)
	del *.obj *.mos

install: $(PROGS)
	$(INSTALLCMD) $(PROGS) $(BINDIR)

print-%  : ; @echo $* = $($*)

avl.exe: $(AOBJS) $(MATRIX)
	$(FC) /exe:avl.exe $(AOBJS) $(MATRIX) $(MLIB) $(ALIBS) $(MLIBSYS) $(PLTOBJ) $(EIGOBJ) $(PLTLIB) $(FTNLIB) $(LFLG)
#	$(INSTALLCMD) avl $(BINDIR)


dtest.exe: dtest.obj
	$(FC) /exe:dtest.exe dtest.obj $(LFLG)

$(SRC)\AVL.INC: $(SRC)\AINDEX.INC
	touch $(SRC)\AVL.INC

avl.obj: $(SRC)\avl.f $(SRC)\AVL.INC $(SRC)\AVLPLT.INC
	$(FC) /c $(FFLAGS) $(SRC)\avl.f
aoper.obj: $(SRC)\aoper.f $(SRC)\AVL.INC $(SRC)\AVLPLT.INC
	$(FC) /c $(FFLAGS) $(SRC)\aoper.f
amode.obj: $(SRC)\amode.f $(SRC)\AVL.INC $(SRC)\AVLPLT.INC
	$(FC) /c $(FFLAGS) $(SRC)\amode.f
amass.obj: $(SRC)\amass.f $(SRC)\AVL.INC
	$(FC) /c $(FFLAGS) $(SRC)\amass.f
asetup.obj: $(SRC)\asetup.f $(SRC)\AVL.INC
	$(FC) /c $(FFLAGS) $(SRC)\asetup.f
cdcl.obj: $(SRC)\cdcl.f $(SRC)\AVL.INC
	$(FC) /c $(FFLAGS)  $(SRC)\cdcl.f
amake.obj: $(SRC)\amake.f $(SRC)\AVL.INC
	$(FC) /c $(FFLAGS) $(SRC)\amake.f
ainput.obj: $(SRC)\ainput.f $(SRC)\AVL.INC
	$(FC) /c $(FFLAGS) $(SRC)\ainput.f
aoutput.obj: $(SRC)\aoutput.f $(SRC)\AVL.INC
	$(FC) /c $(FFLAGS) $(SRC)\aoutput.f
aoutmrf.obj: $(SRC)\aoutmrf.f $(SRC)\AVL.INC
	$(FC) /c $(FFLAGS) $(SRC)\aoutmrf.f
aero.obj: $(SRC)\aero.f $(SRC)\AVL.INC
	$(FC) /c $(FFLAGS) $(SRC)\aero.f
getvm.obj: $(SRC)\getvm.f $(SRC)\AVL.INC
	$(FC) /c $(FFLAGS) $(SRC)\getvm.f
atrim.obj: $(SRC)\atrim.f $(SRC)\AVL.INC
	$(FC) /c $(FFLAGS) $(SRC)\atrim.f
atpforc.obj: $(SRC)\atpforc.f $(SRC)\AVL.INC
	$(FC) /c $(FFLAGS) $(SRC)\atpforc.f
aoml.obj: $(SRC)\aoml.f $(SRC)\AVL.INC
	$(FC) /c $(FFLAGS) $(SRC)\aoml.f
aplotvl.obj: $(SRC)\aplotvl.f $(SRC)\AVL.INC $(SRC)\AVLPLT.INC $(SRC)\MASKS.INC
	$(FC) /c $(FFLAGS) $(SRC)\aplotvl.f
aplottp.obj: $(SRC)\aplottp.f $(SRC)\AVL.INC $(SRC)\AVLPLT.INC $(SRC)\MASKS.INC
	$(FC) /c $(FFLAGS) $(SRC)\aplottp.f
aplotmd.obj: $(SRC)\aplotmd.f $(SRC)\AVL.INC $(SRC)\AVLPLT.INC $(SRC)\MASKS.INC
	$(FC) /c $(FFLAGS) $(SRC)\aplotmd.f
limits.obj: $(SRC)\limits.f $(SRC)\AVL.INC $(SRC)\AVLPLT.INC
	$(FC) /c $(FFLAGS) $(SRC)\limits.f
pltops.obj: $(SRC)\pltops.f $(SRC)\AVLPLT.INC
	$(FC) /c $(FFLAGS) $(SRC)\pltops.f
plsubs.obj: $(SRC)\plsubs.f $(SRC)\AINDEX.INC
	$(FC) /c $(FFLAGS) $(SRC)\plsubs.f
hidden.obj: $(SRC)\hidden.f
	$(FC) /c $(FFLAGS) $(SRC)\hidden.f

matrix.obj: $(SRC)\matrix.f
	$(FC) /c $(FFLAGS)  $(SRC)\matrix.f
matrix-lapacksp.obj: $(SRC)/matrix-lapacksp.f
	$(FC) -c $(FFLGNODP)  $(SRC)/matrix-lapacksp.f
matrix-lapackdp.obj: $(SRC)/matrix-lapackdp.f
	$(FC) -c $(FFLAGS)  $(SRC)/matrix-lapackdp.f
matrix-lapacksubs.obj: $(SRC)/matrix-lapacksubs.f
	$(FC) -c $(FFLGNODP)  $(SRC)/matrix-lapacksubs.f

avl_heap.obj: $(SRC)/avl_heap.f90
	$(FC) -c $(FFLAGS) $(SRC)/avl_heap.f90
avl_heap_inc.obj: $(SRC)/avl_heap_inc.f90
	$(FC) -c $(FFLAGS) $(SRC)/avl_heap_inc.f90

aic.obj: $(SRC)\aic.f
	$(FC) /c $(FFLAGS) $(SRC)\aic.f
userio.obj: $(SRC)\userio.f
	$(FC) /c $(FFLAGS) $(SRC)\userio.f
plutil.obj: $(SRC)\plutil.f $(SRC)\MASKS.INC
	$(FC) /c $(FFLAGS) $(SRC)\plutil.f
arrow3d.obj: $(SRC)\arrow3d.f $(SRC)\MASKS.INC
	$(FC) /c $(FFLAGS) $(SRC)\arrow3d.f

spline.obj: $(SRC)\spline.f
	$(FC) /c $(FFLAGS)  $(SRC)\spline.f
sgutil.obj: $(SRC)\sgutil.f
	$(FC) /c $(FFLAGS)  $(SRC)\sgutil.f
airutil.obj: $(SRC)\airutil.f
	$(FC) /c $(FFLAGS)  $(SRC)\airutil.f
autil.obj: $(SRC)\autil.f
	$(FC) /c $(FFLAGS)  $(SRC)\autil.f

obsetup.o: $(SRC)/obsetup.f
	$(FC) -c $(FFLAGS) $(SRC)/obsetup.f

dtest.obj: $(SRC)\dtest.f
	$(FC) /c $(FFLAGS) $(SRC)\dtest.f

second.obj: $(SRC)\$(SECOND)
	copy $(SRC)\$(SECOND) $(SRC)\second.f
	$(FC) /c $(FFLAGS) $(SRC)\second.f
